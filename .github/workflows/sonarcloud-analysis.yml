name: SonarCloud Analysis
on:
  push:
    branches: [ "main" ]
    paths-ignore:
      - 'Stage-01-poc/**'
  pull_request:
    types: [opened, synchronize, reopened]
    paths-ignore:
      - 'Stage-01-poc/**'

env:
  SOLUTION_DIR: Stage-02-new-architecture/Src

jobs:    
  SonarQubeForDotNet:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # required for SonarCloud analysis
          
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'zulu' # Alternative distribution options are available.
          
      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~\.sonar\cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
          
      - name: Cache SonarQube scanner
        id: cache-sonar-scanner
        uses: actions/cache@v4
        with:
          path: .\.sonar\scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner
          
      - name: Install SonarQube scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          New-Item -Path .\.sonar\scanner -ItemType Directory
          dotnet tool update dotnet-sonarscanner --tool-path .\.sonar\scanner

      - name: SonarCloud Begin
        shell: powershell
        run: |
          .\.sonar\scanner\dotnet-sonarscanner begin `
            /k:"${{ secrets.SONAR_PROJECT_KEY }}" `
            /o:"${{ secrets.SONAR_ORGANIZATION }}" `
            /d:sonar.host.url="https://sonarcloud.io" `
            /d:sonar.token="${{ secrets.SONAR_TOKEN }}" `
            /d:sonar.verbose=true `
            /d:sonar.coverageReportPaths=${{ env.SOLUTION_DIR }}/TestResults/CoverageReport/SonarQube.xml `
            /d:"sonar.coverage.exclusions=**/Migrations/**" `
            /d:"sonar.exclusions=Stage-01-poc/**"

      - name: Build solution
        run: dotnet build ${{ env.SOLUTION_DIR }}/AssetTracker.sln --configuration Release /p:EnableWindowsTargeting=true

      - name: Run tests per test-project (generate per-project cobertura files)
        shell: powershell
        run: |
          $solutionDir = (Resolve-Path "${{ env.SOLUTION_DIR }}").Path
          $testResultsDir = Join-Path $solutionDir "TestResults"
          if (-Not (Test-Path $testResultsDir)) {
            New-Item -ItemType Directory -Path $testResultsDir | Out-Null
          }
      
          $testProjects = Get-ChildItem -Path $solutionDir -Recurse -Filter "*.Tests.csproj" | Select-Object -ExpandProperty FullName
          if (-Not $testProjects) {
            Write-Error "No test projects found under $solutionDir"
            exit 1
          }
      
          foreach ($proj in $testProjects) {
            $projName = [System.IO.Path]::GetFileNameWithoutExtension($proj)
            Write-Host "=== Running tests for: $projName ==="
      
            # Run tests for this project
            dotnet test $proj --configuration Release --collect:"XPlat Code Coverage" /p:EnableWindowsTargeting=true
      
            if ($LASTEXITCODE -ne 0) {
              Write-Error "dotnet test failed for $projName"
              exit $LASTEXITCODE
            }
          }

      - name: Collect coverage reports
        shell: pwsh
        run: |
          $testResultsDir = "${{ env.SOLUTION_DIR }}/TestResults"
          New-Item -ItemType Directory -Force -Path $testResultsDir | Out-Null
          
          # Find all coverage.cobertura.xml files recursively
          $coverageFiles = Get-ChildItem -Path ${{ env.SOLUTION_DIR }} -Recurse -Filter "coverage.cobertura.xml"
      
          foreach ($file in $coverageFiles) {
              $destFile = Join-Path $testResultsDir "$($file.Directory.Name).coverage.cobertura.xml"
              if ($file.FullName -ne $destFile) {
                  Copy-Item -Path $file.FullName -Destination $destFile -Force
                  Write-Host "Copied coverage from $($file.FullName) to $destFile"
              } else {
                  Write-Host "Skipping copy for $($file.FullName) (already at destination)"
              }
          }

      - name: Verify coverage files
        shell: powershell
        run: |
          $pattern = "${{ env.SOLUTION_DIR }}\TestResults\*.coverage.cobertura.xml"
          Write-Host "Looking for coverage files..."
          Get-ChildItem -Path "${{ env.SOLUTION_DIR }}\TestResults" -Filter "*.coverage.cobertura.xml" -Recurse | ForEach-Object {
            Write-Host "Found: $($_.FullName)"
          }

      - name: Convert coverage reports to SonarQube format
        uses: danielpalme/ReportGenerator-GitHub-Action@v5.3.11
        with:
          reports: '${{ env.SOLUTION_DIR }}/TestResults/*.coverage.cobertura.xml'
          targetdir: '${{ env.SOLUTION_DIR }}/TestResults/CoverageReport'
          reporttypes: 'SonarQube'
          sourcedirs: '${{ github.workspace }}/Stage-02-new-architecture/Src'
          filefilters: '+*'
          assemblyfilters: '+*'
          verbosity: 'Verbose'

      - name: Debug generated coverage report
        shell: pwsh
        run: |
          Write-Host "=== Checking SonarQube.xml ==="
          Get-ChildItem -Path "Stage-02-new-architecture/Src/TestResults/CoverageReport" -Recurse
          Get-Content "Stage-02-new-architecture/Src/TestResults/CoverageReport/SonarQube.xml" -Head 30
      
      - name: SonarCloud End (Analyze)
        shell: powershell
        run: |
          .\.sonar\scanner\dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"

