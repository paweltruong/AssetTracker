name: SonarCloud Analysis
on:
  push:
    branches: [ "main" ]
    paths-ignore:
      - 'Stage-01-poc/**'
  pull_request:
    types: [opened, synchronize, reopened]
    paths-ignore:
      - 'Stage-01-poc/**'

env:
  SOLUTION_DIR: Stage-02-new-architecture/Src

jobs:    
  SonarQubeForDotNet:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'zulu'
          
      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~\.sonar\cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
          
      - name: Cache SonarQube scanner
        id: cache-sonar-scanner
        uses: actions/cache@v4
        with:
          path: .\.sonar\scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner
          
      - name: Install SonarQube scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          New-Item -Path .\.sonar\scanner -ItemType Directory
          dotnet tool update dotnet-sonarscanner --tool-path .\.sonar\scanner

      - name: Install Coverlet
        run: dotnet tool install --global coverlet.console

      - name: SonarCloud Begin
        shell: powershell
        run: |
          .\.sonar\scanner\dotnet-sonarscanner begin `
            /k:"${{ secrets.SONAR_PROJECT_KEY }}" `
            /o:"${{ secrets.SONAR_ORGANIZATION }}" `
            /d:sonar.token="${{ secrets.SONAR_TOKEN }}" `
            /d:sonar.host.url="https://sonarcloud.io" `
            /d:sonar.verbose=true `
            /d:"sonar.cs.opencover.reportsPaths=**/coverage.opencover.xml" `
            /d:"sonar.coverage.exclusions=**/Migrations/**" `
            /d:"sonar.exclusions=Stage-01-poc/**"

      - name: Build solution
        run: dotnet build ${{ env.SOLUTION_DIR }}/AssetTracker.sln --configuration Release /p:EnableWindowsTargeting=true

      - name: Run tests with Coverlet MSBuild integration
        shell: powershell
        run: |
          $testProjects = Get-ChildItem -Path "${{ env.SOLUTION_DIR }}" -Recurse -Filter "*.Tests.csproj"
          
          foreach ($proj in $testProjects) {
              $projName = $proj.BaseName
              $coverageFile = Join-Path $proj.DirectoryName "coverage.opencover.xml"
              
              Write-Host "=== Running tests with Coverlet MSBuild for: $projName ==="
              
              # Use Coverlet MSBuild integration
              dotnet test $proj.FullName `
                --configuration Release `
                --no-build `
                --logger "trx;LogFileName=results.trx" `
                --settings coverlet.runsettings `
                --results-directory TestResults
              
              # Check if coverage was generated in the expected location
              $possiblePaths = @(
                  (Join-Path $proj.DirectoryName "coverage.opencover.xml"),
                  (Join-Path $proj.DirectoryName "TestResults\coverage.opencover.xml"),
                  (Join-Path $proj.DirectoryName "TestResults\*\coverage.opencover.xml")
              )
              
              foreach ($path in $possiblePaths) {
                  if (Test-Path $path) {
                      Write-Host "âœ“ Coverage found at: $path"
                      # Copy to consistent location
                      Copy-Item $path $coverageFile -Force
                      break
                  }
              }
          }

      - name: Debug generated coverage files
        shell: pwsh
        run: |
          Write-Host "=== Coverage files and their contents ==="
          $coverageFiles = Get-ChildItem -Path . -Recurse -Filter "coverage.opencover.xml"
          foreach ($file in $coverageFiles) {
              Write-Host "File: $($file.FullName)"
              if (Test-Path $file.FullName) {
                  [xml]$xml = Get-Content $file.FullName -ErrorAction SilentlyContinue
                  if ($xml -and $xml.CoverageSession -and $xml.CoverageSession.Modules) {
                      $xml.CoverageSession.Modules.Module | Select-Object -First 1 | ForEach-Object {
                          Write-Host "  Module: $($_.fullName)"
                          $_.Files.File | Select-Object -First 3 | ForEach-Object {
                              Write-Host "    File path in coverage: $($_.fullPath)"
                          }
                      }
                  }
              }
          }

      - name: SonarCloud End (Analyze)
        shell: powershell
        run: |
          .\.sonar\scanner\dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"

      - name: Print directory tree
        shell: pwsh
        run: |
          Write-Host "=== Current Directory: $(Get-Location) ==="
          tree "$(Get-Location)" /F /A

      - name: List generated OpenCover reports
        shell: pwsh
        run: |
          Write-Host "=== Listing all coverage.opencover.xml files ==="
          Get-ChildItem -Path "${{ env.SOLUTION_DIR }}" -Recurse -Filter "coverage.opencover.xml" | ForEach-Object {
            Write-Host "Found: $($_.FullName)"
          }

      - name: Inspect OpenCover XML contents
        shell: pwsh
        run: |
          $coverageFiles = Get-ChildItem -Path "${{ env.SOLUTION_DIR }}" -Recurse -Filter "coverage.opencover.xml"
          foreach ($file in $coverageFiles) {
              Write-Host "`n=== Showing first lines of: $($file.FullName) ==="
              Get-Content $file -Head 100 | Out-String
          }
      
      - name: Debug Sonar properties
        shell: pwsh
        run: |
          Write-Host "=== Contents of .sonarqube/out/sonar-project.properties ==="
          Get-Content ".sonarqube/out/sonar-project.properties" | Out-String

